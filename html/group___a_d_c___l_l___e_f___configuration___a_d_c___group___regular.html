<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32F4xx_HAL_Driver: Configuration of ADC hierarchical scope: group regular</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STM32F4xx_HAL_Driver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Configuration of ADC hierarchical scope: group regular<div class="ingroups"><a class="el" href="group___s_t_m32_f4xx___l_l___driver.html">STM32F4xx_LL_Driver</a> &raquo; <a class="el" href="group___a_d_c___l_l.html">ADC</a> &raquo; <a class="el" href="group___a_d_c___l_l___exported___functions.html">ADC Exported Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga46331bb05afe971e9ad6b54efd5f07ee">LL_ADC_REG_SetTriggerSource</a> (ADC_TypeDef *ADCx, uint32_t TriggerSource)</td></tr>
<tr class="memdesc:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line).  <a href="#ga46331bb05afe971e9ad6b54efd5f07ee">More...</a><br /></td></tr>
<tr class="separator:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga881dbc8fa2421ca421677fdb4f1a4b6e">LL_ADC_REG_GetTriggerSource</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line).  <a href="#ga881dbc8fa2421ca421677fdb4f1a4b6e">More...</a><br /></td></tr>
<tr class="separator:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaaa50f143fbbb1df8671053e1a7aec8c3">LL_ADC_REG_IsTriggerSourceSWStart</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger source internal (SW start) or external.  <a href="#gaaa50f143fbbb1df8671053e1a7aec8c3">More...</a><br /></td></tr>
<tr class="separator:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga8006f5461d8d6a5f16c329e18bffc9e0">LL_ADC_REG_GetTriggerEdge</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger polarity.  <a href="#ga8006f5461d8d6a5f16c329e18bffc9e0">More...</a><br /></td></tr>
<tr class="separator:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2d56f5d16468ef4672cc9d24883a64"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength</a> (ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)</td></tr>
<tr class="memdesc:gaad2d56f5d16468ef4672cc9d24883a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequencer length and scan direction.  <a href="#gaad2d56f5d16468ef4672cc9d24883a64">More...</a><br /></td></tr>
<tr class="separator:gaad2d56f5d16468ef4672cc9d24883a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga0b6cfe92543aae7cb919a0edb2c77846">LL_ADC_REG_GetSequencerLength</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequencer length and scan direction.  <a href="#ga0b6cfe92543aae7cb919a0edb2c77846">More...</a><br /></td></tr>
<tr class="separator:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga12a6e0ce4a5f8cf96c02307bbfa32e48">LL_ADC_REG_SetSequencerDiscont</a> (ADC_TypeDef *ADCx, uint32_t SeqDiscont)</td></tr>
<tr class="memdesc:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks.  <a href="#ga12a6e0ce4a5f8cf96c02307bbfa32e48">More...</a><br /></td></tr>
<tr class="separator:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gad88e5a0dfe8f2a9d7c24b379e59d92b3">LL_ADC_REG_GetSequencerDiscont</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. @rmtoll CR1 DISCEN LL_ADC_REG_GetSequencerDiscont<br />
 CR1 DISCNUM LL_ADC_REG_GetSequencerDiscont.  <a href="#gad88e5a0dfe8f2a9d7c24b379e59d92b3">More...</a><br /></td></tr>
<tr class="separator:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b090ec6eceed161cd96a04a9debc18"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaa2b090ec6eceed161cd96a04a9debc18">LL_ADC_REG_SetSequencerRanks</a> (ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)</td></tr>
<tr class="memdesc:gaa2b090ec6eceed161cd96a04a9debc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequence: channel on the selected scan sequence rank.  <a href="#gaa2b090ec6eceed161cd96a04a9debc18">More...</a><br /></td></tr>
<tr class="separator:gaa2b090ec6eceed161cd96a04a9debc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7c4a7a145176189253b82c2c923e1a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaae7c4a7a145176189253b82c2c923e1a">LL_ADC_REG_GetSequencerRanks</a> (ADC_TypeDef *ADCx, uint32_t Rank)</td></tr>
<tr class="memdesc:gaae7c4a7a145176189253b82c2c923e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequence: channel on the selected scan sequence rank.  <a href="#gaae7c4a7a145176189253b82c2c923e1a">More...</a><br /></td></tr>
<tr class="separator:gaae7c4a7a145176189253b82c2c923e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f66e2c13cc70fec9584f58baf136f34"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga1f66e2c13cc70fec9584f58baf136f34">LL_ADC_REG_SetContinuousMode</a> (ADC_TypeDef *ADCx, uint32_t Continuous)</td></tr>
<tr class="memdesc:ga1f66e2c13cc70fec9584f58baf136f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC continuous conversion mode on ADC group regular.  <a href="#ga1f66e2c13cc70fec9584f58baf136f34">More...</a><br /></td></tr>
<tr class="separator:ga1f66e2c13cc70fec9584f58baf136f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f7af9cc898097474db03c390657c3a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga42f7af9cc898097474db03c390657c3a">LL_ADC_REG_GetContinuousMode</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga42f7af9cc898097474db03c390657c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC continuous conversion mode on ADC group regular.  <a href="#ga42f7af9cc898097474db03c390657c3a">More...</a><br /></td></tr>
<tr class="separator:ga42f7af9cc898097474db03c390657c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b37d974442ef9d415338c3174a7b8e2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga9b37d974442ef9d415338c3174a7b8e2">LL_ADC_REG_SetDMATransfer</a> (ADC_TypeDef *ADCx, uint32_t DMATransfer)</td></tr>
<tr class="memdesc:ga9b37d974442ef9d415338c3174a7b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.  <a href="#ga9b37d974442ef9d415338c3174a7b8e2">More...</a><br /></td></tr>
<tr class="separator:ga9b37d974442ef9d415338c3174a7b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaa20ef05a5dbd5e22e2c25ab8916c8677">LL_ADC_REG_GetDMATransfer</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.  <a href="#gaa20ef05a5dbd5e22e2c25ab8916c8677">More...</a><br /></td></tr>
<tr class="separator:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d8dfa3533218124b56a73f76703207"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga76d8dfa3533218124b56a73f76703207">LL_ADC_REG_SetFlagEndOfConversion</a> (ADC_TypeDef *ADCx, uint32_t EocSelection)</td></tr>
<tr class="memdesc:ga76d8dfa3533218124b56a73f76703207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which ADC flag between EOC (end of unitary conversion) or EOS (end of sequence conversions) is used to indicate the end of conversion.  <a href="#ga76d8dfa3533218124b56a73f76703207">More...</a><br /></td></tr>
<tr class="separator:ga76d8dfa3533218124b56a73f76703207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb561a16f52883234e21421179a2f5dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gabb561a16f52883234e21421179a2f5dc">LL_ADC_REG_GetFlagEndOfConversion</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gabb561a16f52883234e21421179a2f5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get which ADC flag between EOC (end of unitary conversion) or EOS (end of sequence conversions) is used to indicate the end of conversion. @rmtoll CR2 EOCS LL_ADC_REG_GetFlagEndOfConversion.  <a href="#gabb561a16f52883234e21421179a2f5dc">More...</a><br /></td></tr>
<tr class="separator:gabb561a16f52883234e21421179a2f5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga42f7af9cc898097474db03c390657c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f7af9cc898097474db03c390657c3a">&#9670;&nbsp;</a></span>LL_ADC_REG_GetContinuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetContinuousMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC continuous conversion mode on ADC group regular. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC continuous conversion mode:<ul>
<li>single mode: one conversion per trigger</li>
<li>continuous mode: after the first trigger, following conversions launched successively automatically. @rmtoll CR2 CONT LL_ADC_REG_GetContinuousMode </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_CONV_SINGLE </li>
<li>LL_ADC_REG_CONV_CONTINUOUS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa20ef05a5dbd5e22e2c25ab8916c8677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20ef05a5dbd5e22e2c25ab8916c8677">&#9670;&nbsp;</a></span>LL_ADC_REG_GetDMATransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetDMATransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode. </p>
<dl class="section note"><dt>Note</dt><dd>If transfer by DMA selected, specifies the DMA requests mode:<ul>
<li>Limited mode (One shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular.</li>
<li>Unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. </li>
</ul>
</dd>
<dd>
If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transfers size will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error (overrun flag and interruption if enabled). </dd>
<dd>
For devices with several ADC instances: ADC multimode DMA settings are available using function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___multimode.html#ga37bf47182cf5025a73cc1c3c52f575e7">LL_ADC_GetMultiDMATransfer()</a>. </dd>
<dd>
To configure DMA source address (peripheral address), use function <a class="el" href="group___a_d_c___l_l___e_f___d_m_a___management.html#ga69758b04f38a928fabb87d4e3d40a402">LL_ADC_DMA_GetRegAddr()</a>. @rmtoll CR2 DMA LL_ADC_REG_GetDMATransfer<br />
 CR2 DDS LL_ADC_REG_GetDMATransfer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_DMA_TRANSFER_NONE </li>
<li>LL_ADC_REG_DMA_TRANSFER_LIMITED </li>
<li>LL_ADC_REG_DMA_TRANSFER_UNLIMITED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb561a16f52883234e21421179a2f5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb561a16f52883234e21421179a2f5dc">&#9670;&nbsp;</a></span>LL_ADC_REG_GetFlagEndOfConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetFlagEndOfConversion </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get which ADC flag between EOC (end of unitary conversion) or EOS (end of sequence conversions) is used to indicate the end of conversion. @rmtoll CR2 EOCS LL_ADC_REG_GetFlagEndOfConversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_FLAG_EOC_SEQUENCE_CONV </li>
<li>LL_ADC_REG_FLAG_EOC_UNITARY_CONV </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad88e5a0dfe8f2a9d7c24b379e59d92b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88e5a0dfe8f2a9d7c24b379e59d92b3">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerDiscont()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerDiscont </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. @rmtoll CR1 DISCEN LL_ADC_REG_GetSequencerDiscont<br />
 CR1 DISCNUM LL_ADC_REG_GetSequencerDiscont. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_DISCONT_DISABLE </li>
<li>LL_ADC_REG_SEQ_DISCONT_1RANK </li>
<li>LL_ADC_REG_SEQ_DISCONT_2RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_3RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_4RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_5RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_6RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_7RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_8RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b6cfe92543aae7cb919a0edb2c77846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6cfe92543aae7cb919a0edb2c77846">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerLength </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequencer length and scan direction. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC group regular sequencer features:<ul>
<li>For devices with sequencer fully configurable (function "LL_ADC_REG_SetSequencerRanks()" available): sequencer length and each rank affectation to a channel are configurable. This function retrieves:<ul>
<li>Sequence length: Number of ranks in the scan sequence.</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from rank 1 to rank n). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerRanks()".</li>
</ul>
</li>
<li>For devices with sequencer not fully configurable (function "LL_ADC_REG_SetSequencerChannels()" available): sequencer length and each rank affectation to a channel are defined by channel number. This function retrieves:<ul>
<li>Sequence length: Number of ranks in the scan sequence is defined by number of channels set in the sequence, rank of each channel is fixed by channel HW number. (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from lowest channel number to highest channel number). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerChannels()". </li>
</ul>
</li>
</ul>
</dd>
<dd>
On this STM32 serie, group regular sequencer configuration is conditioned to ADC instance sequencer mode. If ADC instance sequencer mode is disabled, sequencers of all groups (group regular, group injected) can be configured but their execution is disabled (limited to rank 1). Refer to function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___instance.html#ga1bb71082e165391a3c834f32c29d6184">LL_ADC_SetSequencersScanMode()</a>. </dd>
<dd>
Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel. @rmtoll SQR1 L LL_ADC_REG_SetSequencerLength </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_SCAN_DISABLE </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae7c4a7a145176189253b82c2c923e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7c4a7a145176189253b82c2c923e1a">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerRanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerRanks </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequence: channel on the selected scan sequence rank. </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, ADC group regular sequencer is fully configurable: sequencer length and each rank affectation to a channel are configurable. Refer to description of function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength()</a>. </dd>
<dd>
Depending on devices and packages, some channels may not be available. Refer to device datasheet for channels availability. </dd>
<dd>
Usage of the returned channel number:<ul>
<li>To reinject this channel into another function LL_ADC_xxx: the returned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be used as parameter for another function.</li>
<li>To get the channel number in decimal format: process the returned value with the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). @rmtoll SQR3 SQ1 LL_ADC_REG_GetSequencerRanks<br />
 SQR3 SQ2 LL_ADC_REG_GetSequencerRanks<br />
 SQR3 SQ3 LL_ADC_REG_GetSequencerRanks<br />
 SQR3 SQ4 LL_ADC_REG_GetSequencerRanks<br />
 SQR3 SQ5 LL_ADC_REG_GetSequencerRanks<br />
 SQR3 SQ6 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ7 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ8 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ9 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ10 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ11 LL_ADC_REG_GetSequencerRanks<br />
 SQR2 SQ12 LL_ADC_REG_GetSequencerRanks<br />
 SQR1 SQ13 LL_ADC_REG_GetSequencerRanks<br />
 SQR1 SQ14 LL_ADC_REG_GetSequencerRanks<br />
 SQR1 SQ15 LL_ADC_REG_GetSequencerRanks<br />
 SQR1 SQ16 LL_ADC_REG_GetSequencerRanks </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Rank</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_RANK_1 </li>
<li>LL_ADC_REG_RANK_2 </li>
<li>LL_ADC_REG_RANK_3 </li>
<li>LL_ADC_REG_RANK_4 </li>
<li>LL_ADC_REG_RANK_5 </li>
<li>LL_ADC_REG_RANK_6 </li>
<li>LL_ADC_REG_RANK_7 </li>
<li>LL_ADC_REG_RANK_8 </li>
<li>LL_ADC_REG_RANK_9 </li>
<li>LL_ADC_REG_RANK_10 </li>
<li>LL_ADC_REG_RANK_11 </li>
<li>LL_ADC_REG_RANK_12 </li>
<li>LL_ADC_REG_RANK_13 </li>
<li>LL_ADC_REG_RANK_14 </li>
<li>LL_ADC_REG_RANK_15 </li>
<li>LL_ADC_REG_RANK_16 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 </li>
<li>LL_ADC_CHANNEL_2 </li>
<li>LL_ADC_CHANNEL_3 </li>
<li>LL_ADC_CHANNEL_4 </li>
<li>LL_ADC_CHANNEL_5 </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (1)(2) </li>
<li>LL_ADC_CHANNEL_VBAT (1)</li>
</ul>
(1) On STM32F4, parameter available only on ADC instance: ADC1.<br />
 (2) On devices STM32F42x and STM32F43x, limitation: this internal channel is shared between temperature sensor and Vbat, only 1 measurement path must be enabled.<br />
 (1) For ADC channel read back from ADC register, comparison with internal channel parameter to be done using helper macro __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8006f5461d8d6a5f16c329e18bffc9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8006f5461d8d6a5f16c329e18bffc9e0">&#9670;&nbsp;</a></span>LL_ADC_REG_GetTriggerEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerEdge </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger polarity. </p>
<dl class="section note"><dt>Note</dt><dd>Applicable only for trigger source set to external trigger. </dd>
<dd>
On this STM32 serie, setting of external trigger edge is performed using function <a class="el" href="group___a_d_c___l_l___e_f___operation___a_d_c___group___regular.html#gad25ab601eb144086a0eddc7b393b5343">LL_ADC_REG_StartConversionExtTrig()</a>. @rmtoll CR2 EXTEN LL_ADC_REG_GetTriggerEdge </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_EXT_RISING </li>
<li>LL_ADC_REG_TRIG_EXT_FALLING </li>
<li>LL_ADC_REG_TRIG_EXT_RISINGFALLING </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga881dbc8fa2421ca421677fdb4f1a4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881dbc8fa2421ca421677fdb4f1a4b6e">&#9670;&nbsp;</a></span>LL_ADC_REG_GetTriggerSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerSource </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line). </p>
<dl class="section note"><dt>Note</dt><dd>To determine whether group regular trigger source is internal (SW start) or external, without detail of which peripheral is selected as external trigger, (equivalent to "if(LL_ADC_REG_GetTriggerSource(ADC1) == LL_ADC_REG_TRIG_SOFTWARE)") use function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaaa50f143fbbb1df8671053e1a7aec8c3">LL_ADC_REG_IsTriggerSourceSWStart</a>. </dd>
<dd>
Availability of parameters of trigger sources from timer depends on timers availability on the selected device. @rmtoll CR2 EXTSEL LL_ADC_REG_GetTriggerSource<br />
 CR2 EXTEN LL_ADC_REG_GetTriggerSource </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_SOFTWARE </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_EXTI_LINE11 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa50f143fbbb1df8671053e1a7aec8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa50f143fbbb1df8671053e1a7aec8c3">&#9670;&nbsp;</a></span>LL_ADC_REG_IsTriggerSourceSWStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger source internal (SW start) or external. </p>
<dl class="section note"><dt>Note</dt><dd>In case of group regular trigger source set to external trigger, to determine which peripheral is selected as external trigger, use function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#ga881dbc8fa2421ca421677fdb4f1a4b6e">LL_ADC_REG_GetTriggerSource()</a>. @rmtoll CR2 EXTEN LL_ADC_REG_IsTriggerSourceSWStart </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>"0" if trigger source external trigger Value "1" if trigger source SW start. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f66e2c13cc70fec9584f58baf136f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f66e2c13cc70fec9584f58baf136f34">&#9670;&nbsp;</a></span>LL_ADC_REG_SetContinuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetContinuousMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Continuous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC continuous conversion mode on ADC group regular. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC continuous conversion mode:<ul>
<li>single mode: one conversion per trigger</li>
<li>continuous mode: after the first trigger, following conversions launched successively automatically. </li>
</ul>
</dd>
<dd>
It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode. @rmtoll CR2 CONT LL_ADC_REG_SetContinuousMode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Continuous</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_CONV_SINGLE </li>
<li>LL_ADC_REG_CONV_CONTINUOUS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b37d974442ef9d415338c3174a7b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b37d974442ef9d415338c3174a7b8e2">&#9670;&nbsp;</a></span>LL_ADC_REG_SetDMATransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetDMATransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>DMATransfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode. </p>
<dl class="section note"><dt>Note</dt><dd>If transfer by DMA selected, specifies the DMA requests mode:<ul>
<li>Limited mode (One shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular.</li>
<li>Unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. </li>
</ul>
</dd>
<dd>
If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transfers size will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error (overrun flag and interruption if enabled). </dd>
<dd>
For devices with several ADC instances: ADC multimode DMA settings are available using function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___multimode.html#ga0631b2706225ab48fc166f6ae21156be">LL_ADC_SetMultiDMATransfer()</a>. </dd>
<dd>
To configure DMA source address (peripheral address), use function <a class="el" href="group___a_d_c___l_l___e_f___d_m_a___management.html#ga69758b04f38a928fabb87d4e3d40a402">LL_ADC_DMA_GetRegAddr()</a>. @rmtoll CR2 DMA LL_ADC_REG_SetDMATransfer<br />
 CR2 DDS LL_ADC_REG_SetDMATransfer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">DMATransfer</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_DMA_TRANSFER_NONE </li>
<li>LL_ADC_REG_DMA_TRANSFER_LIMITED </li>
<li>LL_ADC_REG_DMA_TRANSFER_UNLIMITED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76d8dfa3533218124b56a73f76703207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d8dfa3533218124b56a73f76703207">&#9670;&nbsp;</a></span>LL_ADC_REG_SetFlagEndOfConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetFlagEndOfConversion </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>EocSelection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which ADC flag between EOC (end of unitary conversion) or EOS (end of sequence conversions) is used to indicate the end of conversion. </p>
<dl class="section note"><dt>Note</dt><dd>This feature is aimed to be set when using ADC with programming model by polling or interruption (programming model by DMA usually uses DMA interruptions to indicate end of conversion and data transfer). </dd>
<dd>
For ADC group injected, end of conversion (flag&amp;IT) is raised only at the end of the sequence. @rmtoll CR2 EOCS LL_ADC_REG_SetFlagEndOfConversion </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">EocSelection</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_FLAG_EOC_SEQUENCE_CONV </li>
<li>LL_ADC_REG_FLAG_EOC_UNITARY_CONV </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12a6e0ce4a5f8cf96c02307bbfa32e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a6e0ce4a5f8cf96c02307bbfa32e48">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerDiscont()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerDiscont </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SeqDiscont</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. </p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode. </dd>
<dd>
It is not possible to enable both ADC auto-injected mode and ADC group regular sequencer discontinuous mode. @rmtoll CR1 DISCEN LL_ADC_REG_SetSequencerDiscont<br />
 CR1 DISCNUM LL_ADC_REG_SetSequencerDiscont </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SeqDiscont</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_DISCONT_DISABLE </li>
<li>LL_ADC_REG_SEQ_DISCONT_1RANK </li>
<li>LL_ADC_REG_SEQ_DISCONT_2RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_3RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_4RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_5RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_6RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_7RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_8RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad2d56f5d16468ef4672cc9d24883a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2d56f5d16468ef4672cc9d24883a64">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerLength </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SequencerNbRanks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequencer length and scan direction. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC group regular sequencer features:<ul>
<li>For devices with sequencer fully configurable (function "LL_ADC_REG_SetSequencerRanks()" available): sequencer length and each rank affectation to a channel are configurable. This function performs configuration of:<ul>
<li>Sequence length: Number of ranks in the scan sequence.</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from rank 1 to rank n). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerRanks()".</li>
</ul>
</li>
<li>For devices with sequencer not fully configurable (function "LL_ADC_REG_SetSequencerChannels()" available): sequencer length and each rank affectation to a channel are defined by channel number. This function performs configuration of:<ul>
<li>Sequence length: Number of ranks in the scan sequence is defined by number of channels set in the sequence, rank of each channel is fixed by channel HW number. (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from lowest channel number to highest channel number). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerChannels()". </li>
</ul>
</li>
</ul>
</dd>
<dd>
On this STM32 serie, group regular sequencer configuration is conditioned to ADC instance sequencer mode. If ADC instance sequencer mode is disabled, sequencers of all groups (group regular, group injected) can be configured but their execution is disabled (limited to rank 1). Refer to function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___instance.html#ga1bb71082e165391a3c834f32c29d6184">LL_ADC_SetSequencersScanMode()</a>. </dd>
<dd>
Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel. @rmtoll SQR1 L LL_ADC_REG_SetSequencerLength </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SequencerNbRanks</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_SCAN_DISABLE </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2b090ec6eceed161cd96a04a9debc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b090ec6eceed161cd96a04a9debc18">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerRanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequence: channel on the selected scan sequence rank. </p>
<dl class="section note"><dt>Note</dt><dd>This function performs configuration of:<ul>
<li>Channels ordering into each rank of scan sequence: whatever channel can be placed into whatever rank. </li>
</ul>
</dd>
<dd>
On this STM32 serie, ADC group regular sequencer is fully configurable: sequencer length and each rank affectation to a channel are configurable. Refer to description of function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___group___regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength()</a>. </dd>
<dd>
Depending on devices and packages, some channels may not be available. Refer to device datasheet for channels availability. </dd>
<dd>
On this STM32 serie, to measure internal channels (VrefInt, TempSensor, ...), measurement paths to internal channels must be enabled separately. This can be done using function <a class="el" href="group___a_d_c___l_l___e_f___configuration___a_d_c___common.html#gada4e99bea81f03d942d2f6d51b360154">LL_ADC_SetCommonPathInternalCh()</a>. @rmtoll SQR3 SQ1 LL_ADC_REG_SetSequencerRanks<br />
 SQR3 SQ2 LL_ADC_REG_SetSequencerRanks<br />
 SQR3 SQ3 LL_ADC_REG_SetSequencerRanks<br />
 SQR3 SQ4 LL_ADC_REG_SetSequencerRanks<br />
 SQR3 SQ5 LL_ADC_REG_SetSequencerRanks<br />
 SQR3 SQ6 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ7 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ8 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ9 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ10 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ11 LL_ADC_REG_SetSequencerRanks<br />
 SQR2 SQ12 LL_ADC_REG_SetSequencerRanks<br />
 SQR1 SQ13 LL_ADC_REG_SetSequencerRanks<br />
 SQR1 SQ14 LL_ADC_REG_SetSequencerRanks<br />
 SQR1 SQ15 LL_ADC_REG_SetSequencerRanks<br />
 SQR1 SQ16 LL_ADC_REG_SetSequencerRanks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Rank</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_RANK_1 </li>
<li>LL_ADC_REG_RANK_2 </li>
<li>LL_ADC_REG_RANK_3 </li>
<li>LL_ADC_REG_RANK_4 </li>
<li>LL_ADC_REG_RANK_5 </li>
<li>LL_ADC_REG_RANK_6 </li>
<li>LL_ADC_REG_RANK_7 </li>
<li>LL_ADC_REG_RANK_8 </li>
<li>LL_ADC_REG_RANK_9 </li>
<li>LL_ADC_REG_RANK_10 </li>
<li>LL_ADC_REG_RANK_11 </li>
<li>LL_ADC_REG_RANK_12 </li>
<li>LL_ADC_REG_RANK_13 </li>
<li>LL_ADC_REG_RANK_14 </li>
<li>LL_ADC_REG_RANK_15 </li>
<li>LL_ADC_REG_RANK_16 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Channel</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 </li>
<li>LL_ADC_CHANNEL_2 </li>
<li>LL_ADC_CHANNEL_3 </li>
<li>LL_ADC_CHANNEL_4 </li>
<li>LL_ADC_CHANNEL_5 </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (1)(2) </li>
<li>LL_ADC_CHANNEL_VBAT (1)</li>
</ul>
(1) On STM32F4, parameter available only on ADC instance: ADC1.<br />
 (2) On devices STM32F42x and STM32F43x, limitation: this internal channel is shared between temperature sensor and Vbat, only 1 measurement path must be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46331bb05afe971e9ad6b54efd5f07ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46331bb05afe971e9ad6b54efd5f07ee">&#9670;&nbsp;</a></span>LL_ADC_REG_SetTriggerSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetTriggerSource </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>TriggerSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event, external interrupt line). </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, setting of external trigger edge is performed using function <a class="el" href="group___a_d_c___l_l___e_f___operation___a_d_c___group___regular.html#gad25ab601eb144086a0eddc7b393b5343">LL_ADC_REG_StartConversionExtTrig()</a>. </dd>
<dd>
Availability of parameters of trigger sources from timer depends on timers availability on the selected device. @rmtoll CR2 EXTSEL LL_ADC_REG_SetTriggerSource<br />
 CR2 EXTEN LL_ADC_REG_SetTriggerSource </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">TriggerSource</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_SOFTWARE </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM5_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_EXTI_LINE11 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
